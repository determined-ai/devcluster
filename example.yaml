# startup_input is how you configure the UI.  It's literally just a set of keys
# that will be passed into the UI as if you typed them.  This key will turn
# off the db logs:
# startup_input: "!"

# temp_dir is where temporary config files and persistent logs are written to.
# You might overwrite it if you wanted to run multiple concurrent clusters.
# temp_dir: /tmp/devcluster

# commands is where you can assign arbitrary commands to hotkeys.  They should
# be commands that do not otherwise interfere with the state of the cluster.
commands:
  h: make -C harness build
  w: make -C webui build
  c: make -C docs build

# stages is the configuration of the whole cluster.  Each stage must be
# completed before moving to the next stage, so order matters.  This example
# assumes that devcluster.py is responsible for the database, but if you wanted
# to run it externally then you could just remove the "db" stage here.
stages:

  # db is predefined type of stage specific to how determined runs the
  # database.
  - db:
      # port: 5432
      # db_name: determined
      # password: postgres
      # container_name: determined_db
      # image_name: "postgres:10.14"

      # data_dir is where the persistent files will be saved to.  If this key
      # is not present, the database will not persist at all.
      data_dir: ~/.postgres

  # master is a predefined type of stage for to how determined runs the master.
  - master:
      # pre is a set of precommands to be run before starting the master.
      # In this case those commands are just a few make targets, specified
      # as shell commands.
      pre:
        - sh: make -C proto build
        - sh: make -C master build
        - sh: make -C tools prep-root

      # binary: master/build/determined-master

      # post is the set of postcommands to run after starting the master, before
      # considering it "ready".  You probably never have to change this.
      # post:
      #   - logcheck
      #       regex: accepting incoming connections on port

      # config_file is the most important config detail for the master stage.
      # It is literally just master.yaml.
      config_file:
        db:
          host: localhost
          port: 5432
          password: postgres
          user: postgres
          name: determined
        checkpoint_storage:
          type: shared_fs
          host_path: /tmp
          storage_path: determined-cp
        log:
          level: debug
        # This is important: we have to use the symbolic links in the
        # tools/build directory to run properly.
        root: tools/build

  - agent:
      # If you have multiple agent stages, they should have different names.
      # name: agent

      # binary: master/build/determined-agent

      pre:
        - sh: make -C agent build
      config_file:
        # NOTE: you need to put in an address for the master which is
        # resolvable from BOTH inside and outside docker.  I have been using my
        # laptop's external IP address, 192.168.0.4, but you may be able to
        # put your computer's hostname here.  host.docker.internal will not work.
        master_host: MY_IP_ADDR
        master_port: 8080

        # This is a useful setting for testing single-node dtrain on a laptop.
        # artificial_slots: 8


# Example: Introduce a second, non-conflicting agent to test dtrain locally.
# - agent:
#     # Each agent stage should have a unique name for devcluster.
#     name: agent2
#     pre:
#       - sh: make -C agent build
#     config_file:
#       master_host: MY_IP_ADDR
#       master_port: 8080
#       # Often dtrain clusters have multiple gpus per agent.
#       artificial_slots: 8
#       # Each agent needs a unique agent_id.
#       agent_id: agent2
#       # Each agent needs a deconflicting fluent container
#       fluent:
#         port: 24225  # default value is 24224
#         container_name: determined-fluent-2


# Example: a totally custom stage.  This one runs a static http server.
# - custom:
#     # name is required for custom stages
#     name: http
#     # cwd (optional), which dir to run the command from
#     cwd: ~/http-files
#     # cmd is a list of strings
#     cmd: ["python", "-m", "http.server"]
#     # env (optional), environment variables to set for this process
#     # env:
#     #   VARIABLE_NAME: variable_value
#
#     # pre (optional), actions to take before running the stage.  Allowable
#     # entries are `sh` (a single string) or `custom` (a list of strings).
#     # Each value will run in order and must exit 0 in order to proceed with
#     # the stage.
#     # pre:
#     #   - sh: echo hello world
#     #   - custom: ["echo", "hello", "world"]
#
#     # post (optional), actions to take after starting the stage but before
#     # the stage is considered "ready".  The `sh` and `custom` types from
#     # the `pre` config are allowed here, as well as two special entries:
#     #  - logcheck: wait for a match to a regex pattern from process logs
#     #  - conncheck: repeatedly try to connect to a port until it succeeds
#     post:
#       - conncheck:
#           # port is required
#           port: 8000
#           # host defaults to "localhost"
#           # host: localhost
#       # You could use this logcheck instead of the above conncheck:
#       # - logcheck:
#       #     regex: 'Serving HTTP on .* port'
#       #     # you can watch for logs on a different stage name, if needed
#       #     # stream: http


# Example: a totally custom stage in docker.  Another static http server.
# - custom_docker:
#     # name is required for custom_docker stages
#     name: http_docker
#     # container_name is required
#     container_name: http_docker
#     # run_args is a list of strings to `docker container run`
#     run_args:
#       # options for docker run
#       - "-p"
#       - "8001:8000"
#       # image name
#       - "python"
#       # command + args
#       - "python"
#       - "-m"
#       - "http.server"
#     # kill_signal determines how we shut down the container.  Some containers
#     # (like postgres) prefer TERM to KILL.
#     # kill_signal: KILL
#     # pre and post are configured identically.  They do not run in docker.
#     post:
#       - conncheck:
#           port: 8001
